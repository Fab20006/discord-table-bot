import discord
import aiohttp
import asyncio
import io
import os
import json
from urllib.parse import quote
from PIL import Image, ImageDraw, ImageFont
import textwrap

# Configuration pour Render
token = os.environ.get('DISCORD_TOKEN')
if not token:
    raise Exception("âŒ DISCORD_TOKEN non trouvÃ©")

client = discord.Client(intents=discord.Intents.all())

async def generate_table_simple(table_text):
    """
    GÃ©nÃ¨re un tableau simple sans Selenium
    """
    try:
        print("ğŸ”„ GÃ©nÃ©ration tableau simple...")
        
        # CrÃ©er une image avec le texte formatÃ©
        img_width = 800
        img_height = 600
        
        # CrÃ©er l'image avec fond noir (style Ztix)
        img = Image.new('RGB', (img_width, img_height), color='#000000')
        draw = ImageDraw.Draw(img)
        
        # Essayer de charger une police stylÃ©e
        try:
            # Police pour le titre/header
            title_font = ImageFont.truetype("arial.ttf", 32)
            # Police pour le contenu
            content_font = ImageFont.truetype("arial.ttf", 20)
        except:
            # Fallback aux polices par dÃ©faut
            title_font = ImageFont.load_default()
            content_font = ImageFont.load_default()
        
        # Couleurs style Ztix
        title_color = '#FFFFFF'
        text_color = '#FFFFFF'
        accent_color = '#FD4D44'
        
        # Titre
        draw.text((50, 30), "TABLEAU DE SCORES", fill=title_color, font=title_font)
        
        # Ligne sÃ©paratrice
        draw.line([(50, 80), (img_width - 50, 80)], fill=accent_color, width=3)
        
        # Formater le texte en colonnes (simulation de tableau)
        lines = table_text.split('\n')
        y_position = 120
        
        for i, line in enumerate(lines):
            if line.strip():
                # Style alternÃ© pour les lignes
                fill_color = text_color if i % 2 == 0 else '#CCCCCC'
                
                # Ajouter des puces/numÃ©ros
                formatted_line = f"{i+1}. {line}"
                draw.text((60, y_position), formatted_line, fill=fill_color, font=content_font)
                y_position += 35
        
        # Pied de page style Ztix
        draw.line([(50, img_height - 60), (img_width - 50, img_height - 60)], fill=accent_color, width=2)
        draw.text((50, img_height - 45), "Generated by TableBot â€¢ Style Ztix", fill=text_color, font=content_font)
        
        # Sauvegarder en mÃ©moire
        buffer = io.BytesIO()
        img.save(buffer, format='PNG', optimize=True)
        buffer.seek(0)
        
        print("âœ… Tableau gÃ©nÃ©rÃ© avec succÃ¨s")
        return buffer.getvalue()
        
    except Exception as e:
        print(f"âŒ Erreur gÃ©nÃ©ration simple: {e}")
        # Fallback: image d'erreur
        return await generate_fallback_image(str(e))

async def generate_fallback_image(error_msg=""):
    """GÃ©nÃ¨re une image de fallback"""
    img = Image.new('RGB', (600, 400), color='#000000')
    draw = ImageDraw.Draw(img)
    
    try:
        font = ImageFont.truetype("arial.ttf", 20)
    except:
        font = ImageFont.load_default()
    
    draw.text((50, 50), "âŒ Erreur de gÃ©nÃ©ration", fill='#FFFFFF', font=font)
    if error_msg:
        wrapped_error = textwrap.wrap(error_msg, width=50)
        for i, line in enumerate(wrapped_error[:8]):  # Max 8 lignes
            draw.text((50, 100 + i*30), line, fill='#FF4444', font=font)
    
    draw.text((50, 350), "Utilisez un format de tableau simple", fill='#CCCCCC', font=font)
    
    buffer = io.BytesIO()
    img.save(buffer, format='PNG')
    buffer.seek(0)
    return buffer.getvalue()

async def generate_table_from_api(table_text):
    """
    Essaye de gÃ©nÃ©rer via l'API du site (si disponible)
    """
    try:
        print("ğŸŒ Tentative via API...")
        
        async with aiohttp.ClientSession() as session:
            # Essaye diffÃ©rents endpoints possibles
            endpoints = [
                f"https://gb2.hlorenzi.com/api/generate?text={quote(table_text)}",
                f"https://gb2.hlorenzi.com/export?text={quote(table_text)}&format=png",
                f"https://gb2.hlorenzi.com/render?text={quote(table_text)}"
            ]
            
            for endpoint in endpoints:
                try:
                    async with session.get(endpoint, timeout=10) as response:
                        if response.status == 200:
                            content_type = response.headers.get('Content-Type', '')
                            if 'image' in content_type:
                                print("âœ… Image rÃ©cupÃ©rÃ©e via API")
                                return await response.read()
                except:
                    continue
            
            # Si aucune API ne marche, utilise la mÃ©thode simple
            return await generate_table_simple(table_text)
            
    except Exception as e:
        print(f"âŒ Erreur API: {e}")
        return await generate_table_simple(table_text)

@client.event
async def on_message(message: discord.Message):
    if message.author.bot:
        return
    
    if message.content.lower().startswith("maketable"):
        try:
            table_text = message.content[len("maketable"):].strip()
            
            if not table_text:
                await message.channel.send("âŒ **Veuillez fournir le texte du tableau!**")
                return
            
            if len(table_text) > 1500:
                await message.channel.send("âŒ **Texte trop long! Maximum 1500 caractÃ¨res.**")
                return
            
            processing_msg = await message.channel.send("ğŸ”„ GÃ©nÃ©ration en cours (version rapide)...")
            
            try:
                # Timeout court de 15 secondes
                image_data = await asyncio.wait_for(
                    generate_table_from_api(table_text),
                    timeout=15.0
                )
                
                image_file = discord.File(
                    io.BytesIO(image_data), 
                    filename="tableau.png"
                )
                
                await message.channel.send(
                    content=f"ğŸ“Š Tableau gÃ©nÃ©rÃ© pour {message.author.mention}",
                    file=image_file
                )
                
                await processing_msg.delete()
                
            except asyncio.TimeoutError:
                # GÃ©nÃ©ration simple en fallback
                image_data = await generate_table_simple(table_text)
                image_file = discord.File(io.BytesIO(image_data), filename="tableau.png")
                await message.channel.send(
                    content=f"ğŸ“Š Tableau gÃ©nÃ©rÃ© (mode simple) pour {message.author.mention}",
                    file=image_file
                )
                await processing_msg.delete()
                
            except Exception as e:
                await message.channel.send(f"âŒ **Erreur:** {str(e)}")
            
        except Exception as e:
            await message.channel.send(f"âŒ **Erreur:** {str(e)}")
    
    elif message.content.lower() == "!ping":
        await message.channel.send("ğŸ“ Pong! Bot HTTP actif")
    
    elif message.content.lower() == "!help":
        help_text = """
**ğŸ“Š TableBot - Commandes:**
`maketable [texte]` - GÃ©nÃ¨re un tableau
`!ping` - Teste le bot
`!help` - Affiche cette aide

**Format recommandÃ©:**
